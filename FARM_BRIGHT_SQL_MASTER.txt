-- ===================================================================================
-- FARM-BRIGHT DIGI - MASTER HARDENED SCHEMA (CONSOLIDATED)
-- 100% ALIGNMENT: SQL (snake_case) <-> Frontend (camelCase)
-- SECURITY: Tenant Isolation (RLS) + Automated Farm ID Management
-- ===================================================================================

-- 0. PREPARATION & EXTENSIONS
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- ===================================================================================
-- 1. CORE IDENTITY & MULTI-TENANCY
-- ===================================================================================

CREATE TABLE IF NOT EXISTS public.farms (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID REFERENCES auth.users NOT NULL PRIMARY KEY,
    farm_id UUID REFERENCES public.farms(id),
    role TEXT DEFAULT 'admin',
    email TEXT,
    active_season INTEGER DEFAULT 2026,
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ===================================================================================
-- 2. INFRASTRUCTURE TABLES
-- ===================================================================================

CREATE TABLE IF NOT EXISTS public.fields (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    farm_id UUID NOT NULL REFERENCES public.farms(id),
    name TEXT NOT NULL,
    acreage DECIMAL NOT NULL,
    lat DECIMAL,
    lng DECIMAL,
    boundary JSONB,
    -- FSA compliance columns
    fsa_farm_number TEXT,
    fsa_tract_number TEXT,
    fsa_field_number TEXT,
    producer_share DECIMAL,
    irrigation_practice TEXT,
    intended_use TEXT,
    deleted_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.bins (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    farm_id UUID NOT NULL REFERENCES public.farms(id),
    name TEXT NOT NULL,
    capacity DECIMAL NOT NULL,
    deleted_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ===================================================================================
-- 3. ACTIVITY LOGS (RELATIONAL)
-- ===================================================================================

CREATE TABLE IF NOT EXISTS public.plant_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    farm_id UUID NOT NULL REFERENCES public.farms(id),
    field_id UUID REFERENCES public.fields(id),
    field_name TEXT,
    seed_variety TEXT,
    acreage DECIMAL,
    crop TEXT,
    plant_date DATE,
    -- FSA compliance columns
    fsa_farm_number TEXT,
    fsa_tract_number TEXT,
    fsa_field_number TEXT,
    intended_use TEXT,
    producer_share DECIMAL,
    irrigation_practice TEXT,
    season_year INTEGER,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

CREATE TABLE IF NOT EXISTS public.spray_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    farm_id UUID NOT NULL REFERENCES public.farms(id),
    field_id UUID REFERENCES public.fields(id),
    field_name TEXT,
    product TEXT,
    products JSONB, -- Granular product mixture details
    wind_speed DECIMAL,
    temperature DECIMAL,
    spray_date DATE,
    start_time TIME,
    equipment_id TEXT,
    applicator_name TEXT,
    license_number TEXT,
    epa_reg_number TEXT,
    -- Regulatory auditing columns (MDA 2 CSR 70-25.120)
    target_pest TEXT,
    wind_direction TEXT,
    relative_humidity DECIMAL,
    treated_area_size TEXT,
    total_amount_applied TEXT,
    involved_technicians TEXT,
    mixture_rate TEXT,
    total_mixture_volume TEXT,
    season_year INTEGER,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

CREATE TABLE IF NOT EXISTS public.harvest_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    farm_id UUID NOT NULL REFERENCES public.farms(id),
    field_id UUID REFERENCES public.fields(id),
    field_name TEXT,
    destination TEXT,
    bin_id UUID REFERENCES public.bins(id),
    bushels DECIMAL,
    moisture_percent DECIMAL,
    landlord_split_percent DECIMAL,
    harvest_date DATE,
    crop TEXT,
    -- FSA compliance columns
    fsa_farm_number TEXT,
    fsa_tract_number TEXT,
    season_year INTEGER,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

CREATE TABLE IF NOT EXISTS public.hay_harvest_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    farm_id UUID NOT NULL REFERENCES public.farms(id),
    field_id UUID REFERENCES public.fields(id),
    field_name TEXT,
    date DATE,
    bale_count INTEGER,
    cutting_number INTEGER,
    bale_type TEXT,
    temperature DECIMAL,
    conditions TEXT,
    season_year INTEGER,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

CREATE TABLE IF NOT EXISTS public.grain_movements (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    farm_id UUID NOT NULL REFERENCES public.farms(id),
    bin_id UUID REFERENCES public.bins(id),
    bin_name TEXT,
    type TEXT, -- 'in' or 'out'
    bushels DECIMAL,
    moisture_percent DECIMAL,
    source_field_name TEXT,
    destination TEXT,
    price DECIMAL,
    season_year INTEGER,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

CREATE TABLE IF NOT EXISTS public.saved_seeds (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    farm_id UUID NOT NULL REFERENCES public.farms(id),
    name TEXT NOT NULL,
    deleted_at TIMESTAMPTZ
);

CREATE TABLE IF NOT EXISTS public.spray_recipes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    farm_id UUID NOT NULL REFERENCES public.farms(id),
    name TEXT NOT NULL,
    products JSONB, -- Default mix components
    applicator_name TEXT,
    license_number TEXT,
    target_pest TEXT,
    epa_reg_number TEXT,
    deleted_at TIMESTAMPTZ
);

-- ===================================================================================
-- 4. ROW LEVEL SECURITY (RLS) POLICIES
-- ===================================================================================

-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.fields ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bins ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.plant_records ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.spray_records ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.harvest_records ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.hay_harvest_records ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.grain_movements ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.saved_seeds ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.spray_recipes ENABLE ROW LEVEL SECURITY;

-- Profile Policies (Individual Access)
DROP POLICY IF EXISTS "Users can view own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can update own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can insert own profile" ON public.profiles;

CREATE POLICY "Users can view own profile" ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can update own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "Users can insert own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

-- Farm Data Policies (Tenant Isolation via JWT farm_id)
DO $$
DECLARE
    t text;
    tables text[] := ARRAY[
        'fields', 'bins', 'plant_records', 'spray_records', 
        'harvest_records', 'hay_harvest_records', 'grain_movements', 
        'saved_seeds', 'spray_recipes'
    ];
BEGIN
    FOREACH t IN ARRAY tables LOOP
        EXECUTE format('DROP POLICY IF EXISTS "tenant_isolation" ON public.%I', t);
        EXECUTE format('
            CREATE POLICY "tenant_isolation" ON public.%I
            FOR ALL
            USING (
                (farm_id = (auth.jwt() -> ''app_metadata'' ->> ''farm_id'')::uuid)
            )
            WITH CHECK (
                (farm_id = (auth.jwt() -> ''app_metadata'' ->> ''farm_id'')::uuid)
            )', t, t);
    END LOOP;
END $$;

-- ===================================================================================
-- 5. AUTOMATED TRIGGERS & FUNCTIONS
-- ===================================================================================

-- Function: Assign tenant ID on insert automatically from JWT session
CREATE OR REPLACE FUNCTION public.assign_tenant_id()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.farm_id IS NULL THEN
        NEW.farm_id := (auth.jwt() -> 'app_metadata' ->> 'farm_id')::uuid;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply assignment triggers to all app tables
DO $$
DECLARE
    t text;
    tables text[] := ARRAY[
        'fields', 'bins', 'plant_records', 'spray_records', 
        'harvest_records', 'hay_harvest_records', 'grain_movements', 
        'saved_seeds', 'spray_recipes'
    ];
BEGIN
    FOREACH t IN ARRAY tables LOOP
        EXECUTE format('DROP TRIGGER IF EXISTS tr_assign_tenant_id_%I ON public.%I', t, t);
        EXECUTE format('CREATE TRIGGER tr_assign_tenant_id_%I 
                        BEFORE INSERT ON public.%I 
                        FOR EACH ROW 
                        EXECUTE FUNCTION public.assign_tenant_id()', t, t);
    END LOOP;
END $$;

-- Function: Sync farm_id to Auth App Metadata (for RLS enforcement)
CREATE OR REPLACE FUNCTION public.sync_farm_id_to_auth()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE auth.users
    SET raw_app_meta_data = 
        coalesce(raw_app_meta_data, '{}'::jsonb) || 
        jsonb_build_object('farm_id', NEW.farm_id)
    WHERE id = NEW.id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply Sync Trigger to profiles
DROP TRIGGER IF EXISTS tr_sync_farm_id_to_auth ON public.profiles;
CREATE TRIGGER tr_sync_farm_id_to_auth
    AFTER INSERT OR UPDATE OF farm_id ON public.profiles
    FOR EACH ROW
    EXECUTE FUNCTION public.sync_farm_id_to_auth();

-- Function: Handle New Signups (Auto-create profile)
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email)
  VALUES (new.id, new.email);
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply Signup Trigger
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();
